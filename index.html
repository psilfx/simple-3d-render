<!DOCTYPE html>
<html lang="ru" >
	<head>
		<title>Простой 3д рендер</title>
		<meta charset="UTF-8" />
		<script src="js/vector.js"></script>
		<script src="js/render.js"></script>
		<script src="js/wall.js"></script>
		<script src="js/level.js"></script>
		<script src="js/camera.js"></script>
		<script src="js/texture.js"></script>
		<script src="js/lines-extract.js"></script>
	</head>
	<body>
		<canvas id="texture-canvas" width="1280" height="720" style="display: none" ></canvas>
		<canvas id="render-canvas" width="640" height="360" ></canvas>
		<style>
			#render-canvas {
				margin: 0 auto;
				width: 100%;
				user-select: none;
			}
			#texture-render {
				display: none;
			}
		</style>
		<script>
			const canvas   = document.querySelector( "#render-canvas" );
			const tcanvas  = document.querySelector( "#texture-canvas" );
			const context  = canvas.getContext( "2d" , { willReadFrequently: true , alpha: false } );
			const width    = canvas.width;
			const height   = canvas.height;
			const widthH   = ( canvas.width >> 1 ) | 0;
			const heightH  = ( canvas.height >> 1 ) | 0;
			const fov      = Math.PI / 4; // 45 градусов
			const fovHalf  = fov * 0.5;
			const tanHalfFov = Math.tan( fovHalf );
			const camScale = ( 2 * tanHalfFov );
			const scale    = width / camScale;
			const near     = 0.1;
			const far      = 100;
			const textSize = 64;
			const wallHMax = height * 2;
			const render   = new Render();
			const widthMin = -width * 2;
			const widthMax = width * 3;
			
			
		//	let cameraPosition = CreateVector3F( 0 , 0.5 , 0 );
			let cameraPosition = CreateVector3F( -0.89501953125 , 0.5 , 5.3515625 );
			let camNormal = CreateVector3F( 0 , 0 , 0 );
			const camera  = new Camera( cameraPosition );
			
			let cubeVertex = [ 	CreateVector3F( -1 , 0 , 1 ) , CreateVector3F( 1 , 0 , 1 ) ,  CreateVector3F( 1 , 2 , 1 ) , CreateVector3F( -1 , 2 , 1 ) , 
								CreateVector3F( -1 , 2 , 3 ) , CreateVector3F( 1 , 2 , 3 ) ,  CreateVector3F( 1 , 0 , 3 ) , CreateVector3F( -1 , 0 , 3 ) ];
			
			let angleMod   = 1.57;
			let camAngle   = angleMod * 0.5;
			let speed      = 0.2;
			let minDist    = 1;
			let visDist    = 10;
			
			context.strokeStyle = 'green';
			context.lineWidth = 1;
			
			const texture = new Texture( 'img/grass.jpg' );
				  texture.Load();
			
			const cube = new Texture( 'img/cube.jpg' );
				  cube.Load();
			
			const texture1 = new Texture( 'img/cube_1.jpg' );
				  texture1.Load();
				  
			const texture2 = new Texture( 'img/wall.jpg' );
				  texture2.Load();
			
			let lines = [];
			const lineExtract = new LineExtractor();
			let levelImg = new Image();
				levelImg.src = 'img/test-level.png';
				levelImg.onload = function() {
					let tcontext = tcanvas.getContext( '2d' , { willReadFrequently: true }  );
					tcontext.clearRect( 0 , 0 , tcanvas.width, tcanvas.height );
					tcanvas.width  = this.width;
					tcanvas.height = this.height;
					tcontext.drawImage( this , 0 , 0 );
					//Сохраняет пиксели изображения
					let imageData = tcontext.getImageData( 0 , 0 , this.width , this.height );
					lineExtract.Init( imageData );
					lines = lineExtract.FindLines();
				}
			
			let sidesS = [ CreateVector3F( 2 , -1.2 , 0 ) , CreateVector3F( 3 , -1.2 , 0 ) , CreateVector3F( 2 , -1.2 , 1 ) , CreateVector3F( 3 , -1.2 , 1 ) ];
			let sides = [ CreateVector3F( 0 , -1.2 , 0 ) , CreateVector3F( 5 , -1.2 , 0 ) , CreateVector3F( 0 , -1.2 , 5 ) , CreateVector3F( 5 , -1.2 , 5 ) ];
			
			let cubeMod = new Float16Array( 2 );
			let cubeAng = 0;
			let sidesCenter = CreateVector3F( 2.5 , -0.6 , 0.5 );
			
			const level = new Level( 10 , 10 );
				  level.AddWall( CreateVector3F( 5 , 0 , 5 ) , CreateVector3F( 5.1 , 0 , 5 ) , 0.1 , 1 , texture2 );
				  level.AddWall( CreateVector3F( 5.9 , 0 , 5 ) , CreateVector3F( 6 , 0 , 5 ) , 0.1 , 1 , texture2 );
				  level.AddWall( CreateVector3F( 5 , 1 , 5 ) , CreateVector3F( 6 , 1 , 5 ) , 0.1 , 0.1 , texture2 );
				  level.AddWall( CreateVector3F( 7.25 , 0 , 6 ) , CreateVector3F( 7.75 , 0 , 6 ) , 0.5 , 0.5 , cube );
				  level.SetCellTexture( 3 , 3 , texture1 );
			
			const circleAngle360 = 2 * Math.PI;
			const PI             = Math.PI;
			
			//Основной цикл
			function Frame() {
				context.clearRect( 0 , 0 , canvas.width , canvas.height );
				
				
				<!-- // Приводим угол к диапазону [-PI, PI] -->
				<!-- while ( camera.angle > PI )  camera.angle -= circleAngle360; -->
				<!-- while ( camera.angle < -PI ) camera.angle += circleAngle360; -->
				
				camera.Update();
				
				render.ReadBuffer();
				camera.Draw();
				render.DrawBuffer()
			//	camera.DrawMap();
				window.requestAnimationFrame( Frame );
				
			}
			Frame();
			window.addEventListener( "keydown" , function( e ) {
				if( e.keyCode == 87 ) {
					camera.MoveForward( 1 );
				} 
				if( e.keyCode == 83 ) {
					camera.MoveForward( -1 );
				}
				if( e.keyCode == 65 ) {
					camera.MoveStrafe( -1 );
				} 
				if( e.keyCode == 68 ){
					camera.MoveStrafe( 1 );
				}
			});
			window.addEventListener( "mousemove" , function( e ) {
				if( e.movementX > 0 ) camera.angle += 0.01; 
				if( e.movementX < 0 ) camera.angle -= 0.01; 
				camera.Rotate();
				
				//console.log( e.movementX );
			});
			canvas.addEventListener( "click" , async () => {
					await canvas.requestFullscreen();
					await canvas.requestPointerLock( {
						unadjustedMovement: true,
					});
			});
		</script>
	</body>
</html>