<!DOCTYPE html>
<html lang="ru" >
	<head>
		<title>Простой 3д рендер</title>
		<meta charset="UTF-8" />
		<script src="js/vector.js"></script>
		<script src="js/render.js"></script>
		<script src="js/wall.js"></script>
		<script src="js/level.js"></script>
		<script src="js/camera.js"></script>
		<script src="js/texture.js"></script>
		<script src="js/lines-extract.js"></script>
		<script src="js/controls.js"></script>
		<script src="js/collisions.js"></script>
	</head>
	<body>
		<canvas id="texture-canvas" width="1280" height="720" style="display: none" ></canvas>
		<canvas id="render-canvas" width="640" height="360" ></canvas>
		<style>
			#render-canvas {
				margin: 0 auto;
				width: 100%;
				user-select: none;
			}
			#texture-render {
				display: none;
			}
		</style>
		<script>
			const canvas   = document.querySelector( "#render-canvas" );
			const tcanvas  = document.querySelector( "#texture-canvas" );
			const context  = canvas.getContext( "2d" , { willReadFrequently: true , alpha: false } );
			const width    = canvas.width;
			const height   = canvas.height;
			const widthH   = ( canvas.width * 0.5 ) | 0;
			const heightH  = ( canvas.height * 0.5 ) | 0;
			const fov      = Math.PI / 4; // 45 градусов
			const fovHalf  = fov * 0.5;
			const fovStep  = fov / width;
			const tanHalfFov = Math.tan( fovHalf );
			const camScale = ( 2 * tanHalfFov );
			let scale      = ( widthH / tanHalfFov );
			const near     = 0.01;
			const far      = 100;
			const textSize = 64;
			const wallHMax = height * 2;
			const wallHCut = wallHMax * 4;
			
			const widthMin = -width * 2;
			const widthMax = width * 3;
			
			const dist_inv_width  = 1 / width;
			const dist_inv_height = 1 / height;
			const dist_inv_pi     = 1 / Math.PI;
			
			const skyBoxCacheX    = new Uint16Array( width );
			const skyBoxCacheY    = new Uint32Array( height );
			const skyBoxCacheByte = new Uint32Array( width * 4 );
			for( let x = 0; x < width; x++ ) {
				skyBoxCacheX[ x ] = ( x * dist_inv_width * 256 + 512 ) | 0;
			}
			for( let x = 0; x < width * 4; x++ ) {
				skyBoxCacheByte[ x ] = x * 4;
			}
			for( let y = 0; y < height; y++ ) {
				skyBoxCacheY[ y ] = 4096 * ( ( y * dist_inv_height * 256 ) | 0 );
				//console.log( skyBoxCacheY[ y ] );
			}
			
		//	let cameraPosition = CreateVector3F( 0 , 0.5 , 0 );
			let cameraPosition = CreateVector3F( -0.89501953125 , 0.5 , 5.3515625 );
			let camNormal    = CreateVector3F( 0 , 0 , 0 );
			const camera     = new Camera( cameraPosition );
			const camAnim    = new CameraMoveAnimation();
			const collisions = new Collisions();
			const controls   = new Controls();
			const speed      = 0.1;
			const rotSpeed   = 0.025;
			const visDist    = 10;
			const heightStep = visDist / heightH;
			const render     = new Render();
			
			const texture = new Texture( 'img/grass.jpg' );
				  texture.Load();
			
			const cube = new Texture( 'img/cube.jpg' );
				  cube.Load();
			
			const texture1 = new Texture( 'img/cube_1.jpg' );
				  texture1.Load();
				  
			const texture2 = new Texture( 'img/wall.jpg' );
				  texture2.Load();
				  
			const skybox = new Texture( 'img/skybox.jpg' );
				  skybox.Load();

			const level = new Level( 20 , 20 );
				  level.AddWall( CreateVector3F( 1 , 0 , 1 ) , CreateVector3F( 2 , 0 , 1 ) , 1 , 1 , texture2 );
				  level.AddWall( CreateVector3F( 2 , 0 , 1 ) , CreateVector3F( 3 , 0 , 1 ) , 1 , 1 , texture2 );
				  level.AddWall( CreateVector3F( 3 , 0 , 1 ) , CreateVector3F( 4 , 0 , 1 ) , 1 , 1 , texture2 );
				  level.AddWall( CreateVector3F( 5 , 0 , 5 ) , CreateVector3F( 5.1 , 0 , 5 ) , 0.1 , 1 , texture2 );
				  level.AddWall( CreateVector3F( 5.9 , 0 , 5 ) , CreateVector3F( 6 , 0 , 5 ) , 0.1 , 1 , texture2 );
				  level.AddWall( CreateVector3F( 5 , 1 , 5 ) , CreateVector3F( 6 , 1 , 5 ) , 0.1 , 0.1 , texture2 );
				  level.AddWall( CreateVector3F( 7.25 , 0 , 6 ) , CreateVector3F( 7.75 , 0 , 6 ) , 0.5 , 0.5 , cube );
				  level.AddWall( CreateVector3F( 7.75 , 0 , 6 ) , CreateVector3F( 8.13 , 0 , 6 ) , 0.5 , 0.4 , cube );
				  level.AddWall( CreateVector3F( 8.13 , 0 , 6 ) , CreateVector3F( 8.43 , 0 , 6 ) , 0.5 , 0.3 , cube );
				  level.AddWall( CreateVector3F( 8.43 , 0 , 6 ) , CreateVector3F( 8.73 , 0 , 6 ) , 0.5 , 0.2 , cube );
				  level.AddWall( CreateVector3F( 8.73 , 0 , 6 ) , CreateVector3F( 9.03 , 0 , 6 ) , 0.5 , 0.1 , cube );
				  
				  level.AddWall( CreateVector3F( 3 , 0 , 3 ) , CreateVector3F( 4 , 0 , 3 ) , 0.5 , 0.4 , texture1 );
				  level.AddWall( CreateVector3F( 3 , 0.7 , 3 ) , CreateVector3F( 4 , 0.7 , 3 ) , 0.5 , 0.4 , texture1 );
				  level.AddWall( CreateVector3F( 5 , 0 , 8 ) , CreateVector3F( 6 , 0 , 8 ) , 0.5 , 1 , cube );
				  level.AddWall( CreateVector3F( 6 , 0 , 8 ) , CreateVector3F( 7 , 0 , 8 ) , 0.5 , 1 , cube );
				  level.AddWall( CreateVector3F( 7 , 0 , 8 ) , CreateVector3F( 8 , 0 , 8 ) , 0.5 , 1 , cube );
				  level.AddWall( CreateVector3F( 4 , 0 , 8 ) , CreateVector3F( 5 , 0 , 9 ) , 0.15 , 0.4 , cube );
				  level.AddWall( CreateVector3F( 5 , 0 , 9 ) , CreateVector3F( 6 , 0 , 9 ) , 0.15 , 0.4 , cube );
				  level.AddWall( CreateVector3F( 6 , 0 , 9 ) , CreateVector3F( 6.5 , 0 , 9.5 ) , 0.15 , 0.4 , cube );
				let wall =  level.AddWall( CreateVector3F( 8 , 0 , 8 ) , CreateVector3F( 9 , 0 , 8 ) , 0.1 , 1 , cube );
					wall.Rotate( 0.785398 );
				  level.SetCellTexture( 3 , 3 , texture1 );
				let lightColor = new Light( CreateVector3F( 8 , 1 , 7 ) , ColorRGB( 0 , 0 , 100 ) , 10 );
				  level.AddLight( lightColor );
				  level.AddWall( CreateVector3F( 8 , 1 , 7 ) , CreateVector3F( 8.1 , 1 , 7.1 ) , 0.1 , 0.1 , texture2 );
			
			const circleAngle360 = 2 * Math.PI;
			const PI             = Math.PI;
			level.Update();
			let ang = 0;
			//Основной цикл
			//context.clearRect( 0 , 0 , canvas.width , canvas.height );
			render.ReadBuffer();
			function Frame() {
				
				wall.Rotate( ang );
				
				
				controls.Update();
				camera.Update();
				zBufferY.fill( 0 );
				zBufferHeight.fill( 0 );
				zBuffer.fill( visDist );
				
				camera.Draw();
				render.DrawBuffer();
				//camera.DrawMap();
				window.requestAnimationFrame( Frame );
				ang += 0.01;
			}
			Frame();
			window.addEventListener( "keydown" , function( e ) {
				controls.Input( e.keyCode , true );
			});
			window.addEventListener( "keyup" , function( e ) {
				controls.Input( e.keyCode , false );
			});
			window.addEventListener( "mousemove" , function( e ) {
				controls.Mouse( e.movementX , e.movementY );
			});
			document.addEventListener( 'mousedown' , function(event) {
				controls.MouseButton( event.button , true );
			});
			document.addEventListener( 'mouseup' , function(event) {
				controls.MouseButton( event.button , false );
			});

			canvas.addEventListener( "click" , async () => {
					await canvas.requestFullscreen();
					await canvas.requestPointerLock( {
						unadjustedMovement: true,
					});
			});
		</script>
	</body>
</html>